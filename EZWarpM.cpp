#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <windows.h>
#include <shellapi.h>
#include <filesystem>
#include <chrono>
#include <iomanip>
#include <ctime>
#include <random>
#include <set>

namespace fs = std::filesystem;

// --- Helper Functions ---

bool is_admin() {
    BOOL is_admin = FALSE;
    SID_IDENTIFIER_AUTHORITY nt_authority = SECURITY_NT_AUTHORITY;
    PSID administrators_group;
    if (AllocateAndInitializeSid(&nt_authority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &administrators_group)) {
        CheckTokenMembership(NULL, administrators_group, &is_admin);
        FreeSid(administrators_group);
    }
    return is_admin;
}

void run_as_admin(int argc, char* argv[]) {
    wchar_t path[MAX_PATH];
    GetModuleFileNameW(NULL, path, MAX_PATH);
    std::wstringstream args;
    for (int i = 1; i < argc; ++i) {
        args << argv[i] << " ";
    }
    SHELLEXECUTEINFOW sei = { sizeof(sei) };
    sei.lpVerb = L"runas";
    sei.lpFile = path;
    sei.lpParameters = args.str().c_str();
    sei.nShow = SW_SHOWNORMAL;
    ShellExecuteExW(&sei);
}

std::string run_command(const std::string& command, const std::string& input = "", const std::string& cwd = ".") {
    HANDLE g_hChildStd_IN_Rd = NULL;
    HANDLE g_hChildStd_IN_Wr = NULL;
    HANDLE g_hChildStd_OUT_Rd = NULL;
    HANDLE g_hChildStd_OUT_Wr = NULL;

    SECURITY_ATTRIBUTES saAttr;
    saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
    saAttr.bInheritHandle = TRUE;
    saAttr.lpSecurityDescriptor = NULL;

    CreatePipe(&g_hChildStd_OUT_Rd, &g_hChildStd_OUT_Wr, &saAttr, 0);
    SetHandleInformation(g_hChildStd_OUT_Rd, HANDLE_FLAG_INHERIT, 0);
    CreatePipe(&g_hChildStd_IN_Rd, &g_hChildStd_IN_Wr, &saAttr, 0);
    SetHandleInformation(g_hChildStd_IN_Wr, HANDLE_FLAG_INHERIT, 0);

    PROCESS_INFORMATION piProcInfo;
    STARTUPINFOA siStartInfo;
    ZeroMemory(&piProcInfo, sizeof(PROCESS_INFORMATION));
    ZeroMemory(&siStartInfo, sizeof(STARTUPINFOA));
    siStartInfo.cb = sizeof(STARTUPINFOA);
    siStartInfo.hStdError = g_hChildStd_OUT_Wr;
    siStartInfo.hStdOutput = g_hChildStd_OUT_Wr;
    siStartInfo.hStdInput = g_hChildStd_IN_Rd;
    siStartInfo.dwFlags |= STARTF_USESTDHANDLES;

    CreateProcessA(NULL, (LPSTR)command.c_str(), NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, cwd.c_str(), &siStartInfo, &piProcInfo);

    if (!input.empty()) {
        DWORD dwWritten;
        WriteFile(g_hChildStd_IN_Wr, input.c_str(), input.length(), &dwWritten, NULL);
    }
    CloseHandle(g_hChildStd_IN_Wr);
    CloseHandle(g_hChildStd_OUT_Wr);

    DWORD dwRead;
    CHAR chBuf[4096];
    std::string output;
    while (ReadFile(g_hChildStd_OUT_Rd, chBuf, 4096, &dwRead, NULL) && dwRead != 0) {
        output.append(chBuf, dwRead);
    }

    CloseHandle(piProcInfo.hProcess);
    CloseHandle(piProcInfo.hThread);
    CloseHandle(g_hChildStd_OUT_Rd);
    CloseHandle(g_hChildStd_IN_Rd);

    return output;
}

bool is_process_running(const std::string& pid) {
    std::string command = "tasklist /FI \"PID eq " + pid + "\"";
    std::string output = run_command(command);
    return output.find(pid) != std::string::npos;
}

void run_masque_scan(const fs::path& script_dir, const fs::path& config_dir) {
    std::cout << "--- Preparing for MASQUE endpoint scan... ---" << std::endl;

    fs::path warp_exe_path = script_dir / "warp.exe";
    if (!fs::exists(warp_exe_path)) {
        std::cerr << "Error: 'warp.exe' not found in " << script_dir << ". Cannot perform IP scan." << std::endl;
        exit(1);
    }

    std::cout << "Generating ip.txt and running warp.exe -masque. This may take a while..." << std::endl;

    fs::path ip_txt_path = script_dir / "ip.txt";
    std::ofstream ip_file(ip_txt_path);
    ip_file << "2606:4700:103::/126" << std::endl;
    ip_file.close();

    // Ensure result.csv exists before running warp.exe
    fs::path result_csv_path_in_script_dir = script_dir / "result.csv";
    if (fs::exists(result_csv_path_in_script_dir)) {
        fs::remove(result_csv_path_in_script_dir);
    }
    std::ofstream(result_csv_path_in_script_dir).close(); // Create an empty file

    run_command("warp.exe -masque", "", script_dir.string());

    fs::path result_csv_path_in_config_dir = config_dir / "result.csv";

    if (fs::exists(result_csv_path_in_script_dir)) {
        if (fs::exists(result_csv_path_in_config_dir)) {
            fs::remove(result_csv_path_in_config_dir);
        }
        fs::rename(result_csv_path_in_script_dir, result_csv_path_in_config_dir);
    } else {
        std::cerr << "Warning: 'result.csv' was not generated by 'warp.exe -masque' in " << script_dir << std::endl;
    }

    fs::remove(ip_txt_path);
}

std::vector<std::string> get_endpoints(const fs::path& csv_path) {
    std::vector<std::string> endpoints;
    if (!fs::exists(csv_path)) {
        return endpoints;
    }

    std::ifstream file(csv_path);
    std::string line;
    std::getline(file, line); // Skip header

    while (std::getline(file, line)) {
        std::stringstream ss(line);
        std::string ip, loss_str;
        std::getline(ss, ip, ',');
        std::getline(ss, loss_str, ',');

        try {
            float loss = std::stof(loss_str.substr(0, loss_str.find('%')));
            if (loss <= 25) {
                endpoints.push_back(ip);
            }
        } catch (const std::invalid_argument& e) {
            // Ignore lines with invalid loss values
        }
    }

    return endpoints;
}

void remove_endpoint_from_csv(const fs::path& csv_path, const std::string& endpoint_to_remove) {
    std::vector<std::string> lines;
    std::ifstream file_in(csv_path);
    std::string line;
    while (std::getline(file_in, line)) {
        if (line.find(endpoint_to_remove) == std::string::npos) {
            lines.push_back(line);
        }
    }
    file_in.close();

    std::ofstream file_out(csv_path, std::ios::trunc);
    for (const auto& l : lines) {
        file_out << l << std::endl;
    }
}

std::string check_connection_status() {
    std::string output = run_command("warp-cli status");
    // Check for success keywords
    if (output.find("Connected") != std::string::npos ) {
        return "connected";
    }
    // Check for explicit failure keywords
    if (output.find("Unable") != std::string::npos || output.find("Disconnected") != std::string::npos || output.find("失败") != std::string::npos || output.find("断开") != std::string::npos) {
        return "failed";
    }
    // Otherwise, the state is pending
    return "pending";
}

void background_worker() {
    wchar_t exe_path_ws[MAX_PATH];
    GetModuleFileNameW(NULL, exe_path_ws, MAX_PATH);    
    fs::path exe_dir = fs::path(exe_path_ws).parent_path();

    fs::path config_dir = fs::path(getenv("USERPROFILE")) / ".easywarp-masque";
    fs::create_directories(config_dir);
    fs::path log_file = config_dir / "easywarp-masque.log";
    fs::path pid_file = config_dir / "easywarp-masque.pid";

    std::ofstream pid_out(pid_file);
    pid_out << GetCurrentProcessId();
    pid_out.close();

    // Redirect cout and cerr to log file
    std::ofstream log_stream(log_file, std::ios::trunc);
    std::streambuf* cout_buf = std::cout.rdbuf();
    std::cout.rdbuf(log_stream.rdbuf());
    std::streambuf* cerr_buf = std::cerr.rdbuf();
    std::cerr.rdbuf(log_stream.rdbuf());

    auto now = std::chrono::system_clock::now();
    std::time_t now_c = std::chrono::system_clock::to_time_t(now);
    std::cout << "--- Background MASQUE worker started (PID: " << GetCurrentProcessId() << ") at " << std::put_time(std::localtime(&now_c), "%Y-%m-%d %H:%M:%S") << " ---" << std::endl;

    fs::path csv_path = config_dir / "result.csv";

    if (!fs::exists(csv_path)) {
        std::cout << "'result.csv' not found. Running MASQUE endpoint scan..." << std::endl;
        run_masque_scan(exe_dir, config_dir);
    }

    while (true) {
        auto endpoints = get_endpoints(csv_path);
        if (endpoints.empty()) {
            std::cout << "--- No viable MASQUE endpoints found. Triggering a new scan. ---" << std::endl;
            run_masque_scan(exe_dir, config_dir);
            std::cout << "✅ MASQUE endpoint scan completed successfully." << std::endl;
            Sleep(15000);
            continue;
        }

        std::string endpoint = endpoints[0];
        auto now = std::chrono::system_clock::now();        
        std::time_t now_c = std::chrono::system_clock::to_time_t(now);        
        std::cout << "--- (" << std::put_time(std::localtime(&now_c), "%Y-%m-%d %H:%M:%S") << ") Attempting MASQUE endpoint: " << endpoint << " ---" << std::endl;

        run_command("warp-cli disconnect");
        Sleep(500);
        run_command("warp-cli tunnel protocol set MASQUE");
        Sleep(500);
        run_command("warp-cli tunnel endpoint reset");
        Sleep(500);
        run_command("warp-cli tunnel endpoint set " + endpoint);
        Sleep(500);
        run_command("warp-cli connect");

        std::string connection_result = "pending";
        for (int i = 0; i < 5; ++i) { // Poll for 25 seconds (5 checks, 5 seconds apart)
            Sleep(5000);
            std::string status = check_connection_status();
            std::cout << "Connection attempt " << (i + 1) << "/5... status is: " << status << std::endl;
            if (status == "connected") {
                connection_result = "connected";
                break;
            }
            if (status == "failed") {
                connection_result = "failed";
                break;
            }
            // if status is "pending", loop continues
        }

        if (connection_result == "connected") {
            auto now_success = std::chrono::system_clock::now();
            std::time_t now_c_success = std::chrono::system_clock::to_time_t(now_success);
            std::cout << "✅ (" << std::put_time(std::localtime(&now_c_success), "%Y-%m-%d %H:%M:%S") << ") Connection successful with: " << endpoint << std::endl;
            
            fs::path current_endpoint_file = config_dir / "current_endpoint.txt";
            std::ofstream(current_endpoint_file) << endpoint;

            while (true) {
                Sleep(7000);
                if (check_connection_status() == "failed") {
                    auto now_fail = std::chrono::system_clock::now();
                    std::time_t now_c_fail = std::chrono::system_clock::to_time_t(now_fail);
                    std::cout << "❌ (" << std::put_time(std::localtime(&now_c_fail), "%Y-%m-%d %H:%M:%S") << ") Connection lost with: " << endpoint << "." << std::endl;
                    remove_endpoint_from_csv(csv_path, endpoint);
                    break;
                } else {
                    std::cout << "✅ " << endpoint << " is connecting correctly via MASQUE" << std::endl;
                }
            }
        } else {
            auto now_fail = std::chrono::system_clock::now();
            std::time_t now_c_fail = std::chrono::system_clock::to_time_t(now_fail);
            std::cout << "❌ (" << std::put_time(std::localtime(&now_c_fail), "%Y-%m-%d %H:%M:%S") << ") Connection failed for " << endpoint << "." << std::endl;
            remove_endpoint_from_csv(csv_path, endpoint);
        }
    }
}

void internal_stop_logic() {
    fs::path config_dir = fs::path(getenv("USERPROFILE")) / ".easywarp-masque";
    fs::path pid_file = config_dir / "easywarp-masque.pid";
    fs::path current_endpoint_file = config_dir / "current_endpoint.txt";

    run_command("warp-cli disconnect");
    Sleep(1500);

    if (fs::exists(pid_file)) {
        std::ifstream pid_in(pid_file);
        std::string pid_str;
        pid_in >> pid_str;
        if (!pid_str.empty()) {
            run_command("taskkill /F /PID " + pid_str);
        }
        Sleep(1000);
    }
    if (fs::exists(current_endpoint_file)) {
        fs::remove(current_endpoint_file);
    }
}

void start_easywarp() {
    fs::path config_dir = fs::path(getenv("USERPROFILE")) / ".easywarp-masque";
    fs::create_directories(config_dir);
    fs::path pid_file = config_dir / "easywarp-masque.pid";

    if (fs::exists(pid_file)) {
        std::ifstream pid_in(pid_file);
        std::string pid_str;
        pid_in >> pid_str;
        run_command("warp-cli disconnect");
        Sleep(500);
        run_command("taskkill /F /PID " + pid_str);
        Sleep(1000);
    }

    wchar_t path[MAX_PATH];
    GetModuleFileNameW(NULL, path, MAX_PATH);
    std::wstring command = L"\"" + std::wstring(path) + L"\" start-background";

    STARTUPINFOW si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);
    ZeroMemory(&pi, sizeof(pi));

    CreateProcessW(NULL, &command[0], NULL, NULL, FALSE, CREATE_NO_WINDOW, NULL, NULL, &si, &pi);

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
}

void stop_easywarp() {
    fs::path config_dir = fs::path(getenv("USERPROFILE")) / ".easywarp-masque";
    fs::path log_file = config_dir / "easywarp-masque.log";

    std::ofstream log_stream(log_file, std::ios::app);
    std::streambuf* cout_buf = std::cout.rdbuf();
    std::cout.rdbuf(log_stream.rdbuf());
    std::streambuf* cerr_buf = std::cerr.rdbuf();
    std::cerr.rdbuf(log_stream.rdbuf());

    internal_stop_logic();
    std::cout << "easywarp-masque quit successfully" << std::endl;

    log_stream.close();

    std::cout.rdbuf(cout_buf);
    std::cerr.rdbuf(cerr_buf);
}

void show_log() {
    fs::path config_dir = fs::path(getenv("USERPROFILE")) / ".easywarp-masque";
    fs::path log_file = config_dir / "easywarp-masque.log";
    if (!fs::exists(log_file)) {
        std::cout << "(Log file does not exist)" << std::endl;
        return;
    }
    std::ifstream log_in(log_file);
    std::cout << log_in.rdbuf();
}

void next_node() {
    fs::path config_dir = fs::path(getenv("USERPROFILE")) / ".easywarp-masque";
    fs::path pid_file = config_dir / "easywarp-masque.pid";

    if (!fs::exists(pid_file)) {
        std::cout << "easywarp-masque is not running" << std::endl;
        return;
    }

    std::ifstream pid_in(pid_file);
    std::string pid_str;
    pid_in >> pid_str;
    pid_in.close();

    if (pid_str.empty() || !is_process_running(pid_str)) {
        std::cout << "easywarp-masque is not running" << std::endl;
        if(fs::exists(pid_file)) fs::remove(pid_file);
        return;
    }

    std::cout << "Switching to the next MASQUE node..." << std::endl;

    fs::path csv_path = config_dir / "result.csv";
    fs::path current_endpoint_file = config_dir / "current_endpoint.txt";
    std::string endpoint_to_remove;

    if (fs::exists(current_endpoint_file)) {
        std::ifstream endpoint_in(current_endpoint_file);
        endpoint_in >> endpoint_to_remove;
    }

    internal_stop_logic();

    if (!endpoint_to_remove.empty()) {
        std::cout << "Removing previous endpoint from list: " << endpoint_to_remove << std::endl;
        remove_endpoint_from_csv(csv_path, endpoint_to_remove);
    }

    std::cout << "Restarting easywarp-masque..." << std::endl;
    start_easywarp();
    std::cout << "easywarp-masque restarted. Check log for new connection status." << std::endl;
}


int main(int argc, char* argv[]) {
    SetConsoleOutputCP(CP_UTF8);
    if (argc < 2) {
        std::cerr << "Usage: easywarp-masque [start|stop|log|update|next]" << std::endl;
        return 1;
    }

    std::string command = argv[1];
    for (auto& c : command) {
        c = tolower(c);
    }

    if (command == "start" || command == "stop" || command == "start-background" || command == "update" || command == "next") {
        if (!is_admin()) {
            run_as_admin(argc, argv);
            return 0;
        }
    }

    if (command == "start") {
        start_easywarp();
    } else if (command == "start-background") {
        background_worker();
    } else if (command == "stop") {
        stop_easywarp();
    } else if (command == "log") {
        show_log();
    } else if (command == "update") {
        wchar_t exe_path_ws[MAX_PATH];
        GetModuleFileNameW(NULL, exe_path_ws, MAX_PATH);
        fs::path script_dir = fs::path(exe_path_ws).parent_path();
        fs::path config_dir = fs::path(getenv("USERPROFILE")) / ".easywarp-masque";
        fs::create_directories(config_dir);
        run_masque_scan(script_dir, config_dir);
    } else if (command == "next") {
        next_node();
    }
    else {
        std::cerr << "Unknown command: " << command << std::endl;
        std::cerr << "Usage: easywarp-masque [start|stop|log|update|next]" << std::endl;
        return 1;
    }

    return 0;
}
